# vim: set sts=2 ts=8 sw=2 tw=99 et ft=python:
import os

# Simple extensions do not need to modify this file.

class SDK(object):
	def __init__(self, sdk, ext, aDef, name, spec, dir):
		self.folder = 'hl2sdk-' + dir
		self.envvar = sdk
		self.ext = ext
		self.code = aDef
		self.define = name
		self.spec = spec
		self.name = dir
		self.path = None # Actual path

		# Support main architectures by default
		if type(spec) is list:
			self.spec = {platform: ['x86', 'x86_64'] for platform in spec}

	def specPasses(self, target):
		platform = target.platform
		return (platform in self.spec and target.arch in self.spec[platform])

WinLinux = ['windows', 'linux']

PossibleSDKs = {
	'hl2dm': SDK('HL2SDKHL2DM', '2.hl2dm', '7', 'HL2DM', WinLinux, 'hl2dm')
}

def ResolveEnvPath(env, folder):
	if env in os.environ:
		path = os.environ[env]
		if os.path.isdir(path):
			return path
		return None

	head = os.getcwd()
	oldhead = None
	while head != None and head != oldhead:
		path = os.path.join(head, folder)
		if os.path.isdir(path):
			return path
		oldhead = head
		head = os.path.split(head)[0]

	return None

def Normalize(path):
	return os.path.abspath(os.path.normpath(path))

class ExtensionConfig(object):
	def __init__(self):
		self.sdks = {}
		self.binaries = []
		self.extensions = []
		self.generated_headers = None
		self.mms_root = None
		self.sm_root = None
		self.compilers = []

		# Prepare multi-arch build (e.g. x86 and/or x64)
		targetArchs = []

		if builder.options.targets:
			targetArchs = builder.options.targets.split(',')
		else:
			targetArchs = [builder.host.arch]

		for arch in targetArchs:
			self.compilers += [builder.DetectCxx(target_arch = arch)]

	@property
	def tag(self):
		if builder.options.debug == '1':
			return 'Debug'
		return 'Release'

	def detectSDKs(self):
		sdk_list = builder.options.sdks.split(',')
		use_all = sdk_list[0] == 'all'
		use_present = sdk_list[0] == 'present'

		for sdk_name in PossibleSDKs:
			sdk = PossibleSDKs[sdk_name]

			if builder.host.platform in sdk.spec:
				if builder.options.hl2sdk_root:
					sdk_path = os.path.join(builder.options.hl2sdk_root, sdk.folder)
				else:
					sdk_path = ResolveEnvPath(sdk.envvar, sdk.folder)
				if sdk_path is None or not os.path.isdir(sdk_path):
					if use_all or sdk_name in sdk_list:
						raise Exception('Could not find a valid path for {0}'.format(sdk.envvar))
					continue
				if use_all or use_present or sdk_name in sdk_list:
					sdk.path = Normalize(sdk_path)
					self.sdks[sdk_name] = sdk

		if len(self.sdks) < 1:
			raise Exception('At least one SDK must be available.')

		if builder.options.sm_path:
			self.sm_root = builder.options.sm_path
		else:
			self.sm_root = ResolveEnvPath('SOURCEMOD18', 'sourcemod-1.8')
			if not self.sm_root:
				self.sm_root = ResolveEnvPath('SOURCEMOD', 'sourcemod')
			if not self.sm_root:
				self.sm_root = ResolveEnvPath('SOURCEMOD_DEV', 'sourcemod-central')

		if not self.sm_root or not os.path.isdir(self.sm_root):
			raise Exception('Could not find a source copy of SourceMod')
		self.sm_root = Normalize(self.sm_root)

		if builder.options.mms_path:
			self.mms_root = builder.options.mms_path
		else:
			self.mms_root = ResolveEnvPath('MMSOURCE112', 'mmsource-1.12')
			if not self.mms_root:
				self.mms_root = ResolveEnvPath('MMSOURCE', 'metamod-source')
			if not self.mms_root:
				self.mms_root = ResolveEnvPath('MMSOURCE_DEV', 'mmsource-central')

		if not self.mms_root or not os.path.isdir(self.mms_root):
			raise Exception('Could not find a source copy of Metamod:Source')
		self.mms_root = Normalize(self.mms_root)

	def configure(self, cxx):
		if cxx.like('gcc'):
			self.configure_gcc(cxx)
		elif cxx.like('msvc'):
			self.configure_msvc(cxx)

		# Optimization
		if builder.options.opt == '1':
			cxx.defines += ['NDEBUG']

		# Debugging
		if builder.options.debug == '1':
			cxx.defines += ['DEBUG', '_DEBUG']

		# Platform-specifics
		if cxx.target.platform == 'linux':
			self.configure_linux(cxx)
		elif cxx.target.platform == 'mac':
			self.configure_mac(cxx)
		elif cxx.target.platform == 'windows':
			self.configure_windows(cxx)

		# Finish up.
		cxx.includes += [
			os.path.join(self.sm_root, 'public'),
		]

		return cxx

	def configure_gcc(self, cxx):
		cxx.defines += [
			'GNUC',
			'HAVE_STDINT_H',
		]
		cxx.cflags += [
			'-fno-strict-aliasing',
			'-fPIC',
			'-fvisibility=hidden',
			'-msse',
			'-pipe',
			'-Wall',
			'-Werror',
			'-Wno-array-bounds',
			'-Wno-dangling-else',
			'-Wno-expansion-to-defined',
			'-Wno-int-to-pointer-cast',
			'-Wno-register',
			'-Wno-sign-compare',
			'-Wno-switch',
			'-Wno-unknown-pragmas',
			'-Wno-unused',
		]
		cxx.cxxflags += [
			'-fno-exceptions',
			'-fno-threadsafe-statics',
			'-fpermissive',
			'-fvisibility-inlines-hidden',
			'-std=c++17',
			'-Wno-non-virtual-dtor',
			'-Wno-overloaded-virtual',
		]

		if cxx.family == 'gcc':
			cxx.cxxflags += [
				'-Wno-class-memaccess',
				'-Wno-error=class-memaccess'
			]
		else:
			cxx.cxxflags += [
				'-Wno-implicit-const-int-float-conversion',
				'-Wno-return-type-c-linkage'
			]

		if cxx.target.arch == 'x86':
			cxx.cflags += ['-m32']
			cxx.linkflags += ['-m32']

		have_gcc = cxx.family == 'gcc'
		have_clang = cxx.family == 'clang'
		if cxx.version >= 'clang-3.6':
			cxx.cxxflags += ['-Wno-inconsistent-missing-override']
		if have_clang or (cxx.version >= 'gcc-4.6'):
			cxx.cflags += ['-Wno-narrowing']
		if have_clang or (cxx.version >= 'gcc-4.7'):
			cxx.cxxflags += ['-Wno-delete-non-virtual-dtor']
		if cxx.version >= 'gcc-4.8':
			cxx.cflags += ['-Wno-unused-result']

		if have_clang:
			cxx.cxxflags += ['-Wno-implicit-exception-spec-mismatch']
			if cxx.version >= 'apple-clang-5.1' or cxx.version >= 'clang-3.4':
				cxx.cxxflags += ['-Wno-deprecated-register']
			else:
				cxx.cxxflags += ['-Wno-deprecated']
			cxx.cflags += ['-Wno-sometimes-uninitialized']

		if have_gcc:
			cxx.cflags += ['-mfpmath=sse']

		if builder.options.opt == '1':
			cxx.cflags += ['-O3']

	def configure_msvc(self, cxx):
		if builder.options.debug == '1':
			cxx.cflags += ['/MTd']
			cxx.linkflags += ['/NODEFAULTLIB:libcmt']
		else:
			cxx.cflags += ['/MT']
		cxx.defines += [
			'_CRT_SECURE_NO_DEPRECATE',
			'_CRT_SECURE_NO_WARNINGS',
			'_CRT_NONSTDC_NO_DEPRECATE',
			'_ITERATOR_DEBUG_LEVEL=0',
		]
		cxx.cflags += [
			'/W3',
		]
		cxx.cxxflags += [
			'/EHsc',
			'/GR-',
			'/TP',
			'/std:c++17',
		]
		cxx.linkflags += [
			'advapi32.lib',
			'comdlg32.lib',
			'gdi32.lib',
			'kernel32.lib',
			'odbc32.lib',
			'odbccp32.lib',
			'ole32.lib',
			'oleaut32.lib',
			'shell32.lib',
			'user32.lib',
			'uuid.lib',
			'winspool.lib',
		]

		if cxx.target.arch == 'x86':
			cxx.linkflags += ['/MACHINE:X86']

		if builder.options.opt == '1':
			cxx.cflags += ['/Ox', '/Zo']
			cxx.linkflags += ['/OPT:ICF', '/OPT:REF']

		if builder.options.debug == '1':
			cxx.cflags += ['/Od', '/RTC1']

		# This needs to be after our optimization flags which could otherwise disable it.
		# Don't omit the frame pointer.
		cxx.cflags += ['/Oy-']

	def configure_linux(self, cxx):
		cxx.defines += ['LINUX', '_LINUX', 'POSIX']

		if cxx.target.arch == 'x86_64':
			cxx.defines += ['_FILE_OFFSET_BITS=64']

		cxx.linkflags += ['-Wl,--exclude-libs,ALL', '-lm']
		if cxx.family == 'gcc':
			cxx.linkflags += ['-static-libgcc']
		elif cxx.family == 'clang':
			cxx.linkflags += ['-lgcc_eh']

	def configure_mac(self, cxx):
		cxx.defines += ['OSX', '_OSX', 'POSIX']
		cxx.cflags += ['-mmacosx-version-min=10.5']
		cxx.linkflags += [
			'-mmacosx-version-min=10.5',
			'-arch', 'i386',
			'-lstdc++',
			'-stdlib=libstdc++',
		]
		cxx.cxxflags += ['-stdlib=libstdc++']

	def configure_windows(self, cxx):
		cxx.defines += ['WIN32', '_WINDOWS']

		if cxx.target.arch == 'x86_64':
			cxx.defines += ['WIN64']

	def ConfigureForExtension(self, context, compiler):
		compiler.cxxincludes += [
			os.path.join(context.currentSourcePath),
			os.path.join(context.currentSourcePath, 'sdk'),
			os.path.join(self.sm_root, 'public', 'amtl'),
			os.path.join(self.sm_root, 'public', 'amtl', 'amtl'),
			os.path.join(self.sm_root, 'public', 'extensions'),
			os.path.join(self.sm_root, 'sourcepawn', 'include'),
		]
		return compiler

	def ConfigureForHL2(self, binary, sdk):
		compiler = binary.compiler
		mms_path = os.path.join(self.mms_root, 'core')

		compiler.cxxincludes += [
			os.path.join(mms_path),
			os.path.join(mms_path, 'sourcehook'),
		]

		defines = ['SE_' + PossibleSDKs[i].define + '=' + PossibleSDKs[i].code for i in PossibleSDKs]
		compiler.defines += defines

		paths = [
			['public'],
			['public', 'engine'],
			['public', 'mathlib'],
			['public', 'vstdlib'],
			['public', 'tier0'],
			['public', 'tier1']
		]

		paths.append(['public', 'game', 'server'])
		paths.append(['public', 'toolframework'])
		paths.append(['game', 'shared'])
		paths.append(['common'])

		compiler.defines += ['SOURCE_ENGINE=' + sdk.code]

		if compiler.like('msvc'):
			compiler.defines += ['COMPILER_MSVC']

			if compiler.target.arch == 'x86':
				compiler.defines += ['COMPILER_MSVC32']
			else:
				compiler.defines += ['COMPILER_MSVC64']
		else:
			compiler.defines += ['COMPILER_GCC']

		if compiler.target.arch == 'x86_64':
			compiler.defines += ['X64BITS', 'PLATFORM_64BITS']

		if builder.host.platform in ['linux', 'mac']:
			compiler.defines += ['NO_HOOK_MALLOC', 'NO_MALLOC_OVERRIDE']

		for path in paths:
			compiler.cxxincludes += [os.path.join(sdk.path, *path)]

		archDir = compiler.target.arch

		if builder.host.platform == 'linux':
			archDir = ('linux' if archDir == 'x86' else 'linux64')
		elif archDir == 'x86_64':
			archDir = 'x64'

		lib_folder = os.path.join(sdk.path, 'lib', 'public', archDir)

		if builder.host.platform in ['linux', 'mac']:
			if compiler.target.arch == 'x86_64':
				compiler.postlink += [
					os.path.join(lib_folder, 'tier1.a'),
					os.path.join(lib_folder, 'mathlib.a')
				]
			else:
				compiler.postlink += [
					os.path.join(lib_folder, 'tier1_i486.a'),
					os.path.join(lib_folder, 'mathlib_i486.a')
				]

		dynamic_libs = []

		if builder.host.platform == 'linux':
			dynamic_libs = ['libtier0_srv.so', 'libvstdlib_srv.so']
		elif builder.host.platform == 'mac':
			compiler.linkflags.append('-liconv')
			dynamic_libs = ['libtier0.dylib', 'libvstdlib.dylib']
		else:
			libs = ['mathlib', 'tier0', 'tier1', 'vstdlib']

			for lib in libs:
				lib_path = os.path.join(lib_folder, lib) + '.lib'
				compiler.linkflags.append(lib_path)

		builder.AddFolder(binary.localFolder)

		for library in dynamic_libs:
			source_path = os.path.join(lib_folder, library)
			output_path = os.path.join(binary.localFolder, library)

			compiler.weaklinkdeps += [builder.AddSymlink(source_path, output_path)]
			compiler.linkflags[0:0] = [library]

		return binary

	def HL2Library(self, context, name, sdk):
		binary = context.compiler.Library(name)
		self.ConfigureForExtension(context, binary.compiler)
		return self.ConfigureForHL2(binary, sdk)

	def HL2Project(self, context, name):
		project = context.LibraryProject(name)
		self.ConfigureForExtension(context, context.compiler)
		return project

	def HL2Config(self, context, name, sdk):
		binary = context.project.Configure(context.compiler, name, '{0} - {1}'.format(self.tag, sdk.name))
		return self.ConfigureForHL2(binary, sdk)

Extension = ExtensionConfig()
Extension.detectSDKs()

# Add additional buildscripts here
BuildScripts = [
	'AMBuilder',
]

if builder.backend == 'amb2':
	BuildScripts += [
		'PackageScript',
	]

builder.Build(BuildScripts, {'Extension': Extension})
